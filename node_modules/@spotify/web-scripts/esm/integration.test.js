var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import 'jest';
import { exec as execCP } from 'child_process';
import { join } from 'path';
import { promisify } from 'util';
import { writeFile as writeFileFS, mkdir as mkdirFS, copyFile as copyFileFS, existsSync, } from 'fs';
import fromEntries from 'object.fromentries';
import * as tempy from 'tempy';
import { default as Debug } from 'debug';
import rimraf from 'rimraf';
import { THIS_ROOT, TSCONFIG } from './Paths';
const dbg = Debug('web-scripts:integration-test');
const root = join(__dirname, '..');
const CLI = join(root, 'bin/web-scripts');
const execPromise = promisify(execCP);
const writeFile = promisify(writeFileFS);
const mkdir = promisify(mkdirFS);
const copyFile = promisify(copyFileFS);
const exec = (cmd, options) => __awaiter(this, void 0, void 0, function* () {
    function _log(resp) {
        if (resp.stdout)
            resp.stdout
                .toString()
                .split('\n')
                .forEach(dbg);
        if (resp.stderr)
            resp.stderr
                .toString()
                .split('\n')
                .forEach(dbg);
    }
    try {
        const resp = yield execPromise(cmd, options);
        _log(resp);
        return resp;
    }
    catch (err) {
        _log(err);
        throw err;
    }
});
const SETUP_REPO_TIMEOUT = 30000;
const TEST_SCRIPTS_TIMEOUT = 60000;
describe('integration tests', () => {
    const MONOREPO_ROOT = join(root, '../..');
    let PKG_ROOT;
    beforeEach(() => {
        PKG_ROOT = tempy.directory();
    });
    describe('help', () => {
        test('The CLI offers help when invoked with no arguments', () => __awaiter(this, void 0, void 0, function* () {
            const result = yield exec(`${CLI}`);
            expect(result.stdout).toMatch('Usage: web-scripts [options] [command]');
        }));
        test('The CLI offers help when invoked with --help flag', () => __awaiter(this, void 0, void 0, function* () {
            const result = yield exec(`${CLI} --help`);
            expect(result.stdout).toMatch('Usage: web-scripts [options] [command]');
        }));
    });
    describe('TypeScript', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            yield setupRepo('index.ts', 'index.test.ts', 'Component.tsx');
        }), SETUP_REPO_TIMEOUT);
        test('Full integration test', () => __awaiter(this, void 0, void 0, function* () { return yield testScripts([], ['--typecheck']); }), TEST_SCRIPTS_TIMEOUT);
    });
    describe('JavaScript', () => {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            yield setupRepo('index.js', 'index.test.js', 'Component.jsx');
        }), SETUP_REPO_TIMEOUT);
        test('Full integration test', () => __awaiter(this, void 0, void 0, function* () { return yield testScripts(['--no-types']); }), TEST_SCRIPTS_TIMEOUT);
    });
    function setupRepo(...fileNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const localDependencies = [
                'react',
                'ts-jest',
                'typescript',
                '@types/jest',
                '@types/react',
                '@types/react-dom',
            ];
            const pkg = {
                name: 'test-pkg',
                scripts: {
                    test: `${CLI} test`,
                    build: `${CLI} build`,
                    lint: `${CLI} lint`,
                    commit: `${CLI} commit`,
                    release: `${CLI} release`,
                },
                dependencies: fromEntries(Object.entries(require(`${THIS_ROOT}/package.json`).dependencies).filter(([k]) => localDependencies.includes(k))),
            };
            const tsConfig = {
                extends: TSCONFIG,
                include: ['src'],
            };
            yield writeFile(join(PKG_ROOT, 'package.json'), JSON.stringify(pkg, null, '  '));
            yield writeFile(join(PKG_ROOT, 'tsconfig.json'), JSON.stringify(tsConfig, null, 2));
            yield mkdir(join(PKG_ROOT, 'src'));
            yield fileNames.map(fileName => copyFile(join(THIS_ROOT, '__fixtures__', fileName), join(PKG_ROOT, 'src', fileName)));
            yield copyFile(join(MONOREPO_ROOT, '.gitignore'), join(PKG_ROOT, '.gitignore'));
            yield exec('yarn', { cwd: PKG_ROOT });
            yield exec('git init', { cwd: PKG_ROOT });
        });
    }
    function testScripts(buildArgs = [], lintArgs = []) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                rimraf.sync(join(PKG_ROOT, 'cjs'));
                expect(existsSync(join(PKG_ROOT, 'cjs/index.js'))).toBe(false);
                yield exec(['yarn build', ...buildArgs].join(' '), { cwd: PKG_ROOT });
                expect(existsSync(join(PKG_ROOT, 'cjs/index.js'))).toBe(true);
                yield exec('yarn test', { cwd: PKG_ROOT });
                yield exec(['yarn lint', ...lintArgs].join(' '), { cwd: PKG_ROOT });
            }
            catch (e) {
                console.log(e.stdout);
                throw e;
            }
        });
    }
});
//# sourceMappingURL=integration.test.js.map