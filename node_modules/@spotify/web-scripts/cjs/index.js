"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = __importDefault(require("commander"));
const Paths_1 = require("./Paths");
const TestTask_1 = require("./Tasks/TestTask");
const BuildTask_1 = require("./Tasks/BuildTask");
const LintTask_1 = require("./Tasks/LintTask");
const CommitTasks_1 = require("./Tasks/CommitTasks");
commander_1.default
    .command('init')
    .description('initialize your package to use web-scripts')
    .action(() => {
    throw new Error('unimplemented');
});
commander_1.default
    .command('build')
    .allowUnknownOption()
    .description('Build your project into esm, cjs, and types folders')
    .option('--no-esm', 'do not build esm target')
    .option('--no-cjs', 'do not build cjs target')
    .option('--no-types', 'do not build types target')
    .action((cmd) => {
    const { esm, types, cjs } = cmd.opts();
    const t = {
        name: 'build',
        esm,
        types,
        cjs,
        restOptions: parseRestOptions(cmd),
    };
    handlePromiseResult(BuildTask_1.buildTask(t));
});
commander_1.default
    .command('test')
    .allowUnknownOption()
    .description('Run tests via jest')
    .option('--config [path]', 'path to jest config', Paths_1.JEST_CONFIG)
    .action((cmd) => {
    const { config } = cmd.opts();
    const t = {
        name: 'test',
        config,
        restOptions: parseRestOptions(cmd),
    };
    const result = TestTask_1.testTask(t);
    handleSpawnResult(result);
});
commander_1.default
    .command('lint')
    .allowUnknownOption()
    .description('Run ESLint and TypeScript to statically analyze your code')
    .option('--config [path]', 'path to ESLint config', Paths_1.ESLINT_CONFIG)
    .option('--typecheck', 'run a TypeScript type check')
    .action((cmd) => {
    const { typecheck, config } = cmd.opts();
    const t = {
        name: 'lint',
        config,
        typecheck,
        restOptions: parseRestOptions(cmd),
    };
    handlePromiseResult(LintTask_1.lintTask(t));
});
commander_1.default
    .command('precommit')
    .allowUnknownOption()
    .description('Locally validate the repo before committing')
    .option('--jest-config [path]', 'path to jest config', Paths_1.JEST_CONFIG)
    .option('--prettier-config [path]', 'path to prettier config', Paths_1.PRETTIER_CONFIG)
    .option('--eslint-config [path]', 'path to eslint config', Paths_1.ESLINT_CONFIG)
    .option('--no-fix', 'Do not auto-fix any static analysis errors')
    .option('--no-tests', 'Do not run Jest tests')
    .action((cmd) => {
    const { fix, tests, 'jest-config': jestConfig, 'eslint-config': eslintConfig, 'prettier-config': prettierConfig, } = cmd.opts();
    const t = {
        name: 'precommit',
        fix,
        tests,
        jestConfig,
        eslintConfig,
        prettierConfig,
        restOptions: parseRestOptions(cmd),
    };
    handleSpawnResult(CommitTasks_1.precommitTask(t));
});
commander_1.default
    .command('commit')
    .allowUnknownOption()
    .description('Create Commitizen commit from staged files')
    .option('--path [path]', 'path for commitizen adapter to use', 'cz-conventional-changelog')
    .action((cmd) => {
    const { path } = cmd.opts();
    const t = {
        name: 'commit',
        path,
        restOptions: parseRestOptions(cmd),
    };
    try {
        CommitTasks_1.commitTask(t);
    }
    catch (err) {
        handleError(err);
    }
});
commander_1.default
    .command('commitmsg')
    .allowUnknownOption()
    .description('Run commitizen commit message validation hook')
    .option('--config [path]', 'path to the commitlint config.', Paths_1.COMMITLINT_CONIFG)
    .action((cmd) => {
    const { config } = cmd.opts();
    const t = {
        name: 'commitmsg',
        config,
        restOptions: parseRestOptions(cmd),
    };
    handleSpawnResult(CommitTasks_1.commitMsgTask(t));
});
commander_1.default
    .command('release')
    .allowUnknownOption()
    .description('Run semantic-release')
    .action((cmd) => {
    const t = {
        name: 'release',
        restOptions: parseRestOptions(cmd),
    };
    handleSpawnResult(CommitTasks_1.releaseTask(t));
});
function handlePromiseResult(result) {
    result.catch(handleError);
}
function handleError(error) {
    console.error(error);
    process.exit(1);
}
function handleSpawnResult(result) {
    if (result.error) {
        throw result.error;
    }
    if (result.status !== 0) {
        process.exit(result.status === null ? 0 : result.status);
    }
}
function parseRestOptions(cmd) {
    return cmd.parseOptions(process.argv).unknown;
}
commander_1.default.parse(process.argv);
if (commander_1.default.args.length === 0) {
    commander_1.default.help();
}
//# sourceMappingURL=index.js.map